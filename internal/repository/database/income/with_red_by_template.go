// Code generated by gowrap. DO NOT EDIT.
// template: ../../templates/red_template.go.tmpl
// gowrap: http://github.com/hexdigest/gowrap

package income

import (
	"context"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/rubengomes8/golang-personal-finances/internal/instrumentation"
	"github.com/rubengomes8/golang-personal-finances/internal/repository"
	"github.com/rubengomes8/golang-personal-finances/internal/repository/models"
)

type IncomeRepoWithRED struct {
	base         repository.IncomeRepo
	histogramVec *prometheus.HistogramVec
}

// DeleteIncome implements repository.IncomeRepo
func (d IncomeRepoWithRED) DeleteIncome(ctx context.Context, i1 int64) (err error) {
	since := time.Now()
	defer func() {
		status := "ok"
		if err != nil {
			status = "error"
		}

		labels := prometheus.Labels{
			"status": status,
			"method": "DeleteIncome",
		}

		observer, err := d.histogramVec.GetMetricWith(labels)
		if err != nil {
			fmt.Printf("Metric: Error to get metric with labels %v\n", labels)
		}

		observer.Observe(float64(time.Since(since).Milliseconds()))
	}()
	return d.base.DeleteIncome(ctx, i1)
}

// GetIncomeByID implements repository.IncomeRepo
func (d IncomeRepoWithRED) GetIncomeByID(ctx context.Context, i1 int64) (i2 models.IncomeView, err error) {
	since := time.Now()
	defer func() {
		status := "ok"
		if err != nil {
			status = "error"
		}

		labels := prometheus.Labels{
			"status": status,
			"method": "GetIncomeByID",
		}

		observer, err := d.histogramVec.GetMetricWith(labels)
		if err != nil {
			fmt.Printf("Metric: Error to get metric with labels %v\n", labels)
		}

		observer.Observe(float64(time.Since(since).Milliseconds()))
	}()
	return d.base.GetIncomeByID(ctx, i1)
}

// GetIncomesByCard implements repository.IncomeRepo
func (d IncomeRepoWithRED) GetIncomesByCard(ctx context.Context, s1 string) (ia1 []models.IncomeView, err error) {
	since := time.Now()
	defer func() {
		status := "ok"
		if err != nil {
			status = "error"
		}

		labels := prometheus.Labels{
			"status": status,
			"method": "GetIncomesByCard",
		}

		observer, err := d.histogramVec.GetMetricWith(labels)
		if err != nil {
			fmt.Printf("Metric: Error to get metric with labels %v\n", labels)
		}

		observer.Observe(float64(time.Since(since).Milliseconds()))
	}()
	return d.base.GetIncomesByCard(ctx, s1)
}

// GetIncomesByCategory implements repository.IncomeRepo
func (d IncomeRepoWithRED) GetIncomesByCategory(ctx context.Context, s1 string) (ia1 []models.IncomeView, err error) {
	since := time.Now()
	defer func() {
		status := "ok"
		if err != nil {
			status = "error"
		}

		labels := prometheus.Labels{
			"status": status,
			"method": "GetIncomesByCategory",
		}

		observer, err := d.histogramVec.GetMetricWith(labels)
		if err != nil {
			fmt.Printf("Metric: Error to get metric with labels %v\n", labels)
		}

		observer.Observe(float64(time.Since(since).Milliseconds()))
	}()
	return d.base.GetIncomesByCategory(ctx, s1)
}

// GetIncomesByDates implements repository.IncomeRepo
func (d IncomeRepoWithRED) GetIncomesByDates(ctx context.Context, t1 time.Time, t2 time.Time) (ia1 []models.IncomeView, err error) {
	since := time.Now()
	defer func() {
		status := "ok"
		if err != nil {
			status = "error"
		}

		labels := prometheus.Labels{
			"status": status,
			"method": "GetIncomesByDates",
		}

		observer, err := d.histogramVec.GetMetricWith(labels)
		if err != nil {
			fmt.Printf("Metric: Error to get metric with labels %v\n", labels)
		}

		observer.Observe(float64(time.Since(since).Milliseconds()))
	}()
	return d.base.GetIncomesByDates(ctx, t1, t2)
}

// InsertIncome implements repository.IncomeRepo
func (d IncomeRepoWithRED) InsertIncome(ctx context.Context, i1 models.IncomeTable) (i2 int64, err error) {
	since := time.Now()
	defer func() {
		status := "ok"
		if err != nil {
			status = "error"
		}

		labels := prometheus.Labels{
			"status": status,
			"method": "InsertIncome",
		}

		observer, err := d.histogramVec.GetMetricWith(labels)
		if err != nil {
			fmt.Printf("Metric: Error to get metric with labels %v\n", labels)
		}

		observer.Observe(float64(time.Since(since).Milliseconds()))
	}()
	return d.base.InsertIncome(ctx, i1)
}

// UpdateIncome implements repository.IncomeRepo
func (d IncomeRepoWithRED) UpdateIncome(ctx context.Context, i1 models.IncomeTable) (i2 int64, err error) {
	since := time.Now()
	defer func() {
		status := "ok"
		if err != nil {
			status = "error"
		}

		labels := prometheus.Labels{
			"status": status,
			"method": "UpdateIncome",
		}

		observer, err := d.histogramVec.GetMetricWith(labels)
		if err != nil {
			fmt.Printf("Metric: Error to get metric with labels %v\n", labels)
		}

		observer.Observe(float64(time.Since(since).Milliseconds()))
	}()
	return d.base.UpdateIncome(ctx, i1)
}

// NewIncomeRepoWithRED returns an instance of the repository.IncomeRepo decorated with red histogram metric
func NewIncomeRepoWithRED(base repository.IncomeRepo, constLabels prometheus.Labels) (decorator repository.IncomeRepo, err error) {
	decorate := os.Getenv("DECORATE")
	if !(decorate == "true" || decorate == "1") {
		return base, nil
	}

	subSystem := "income_repo"

	metricConfig := prometheus.HistogramOpts{
		Namespace:   strings.TrimSpace("system"),
		Subsystem:   subSystem,
		Name:        fmt.Sprintf("%s_red", subSystem),
		Help:        "IncomeRepo RED histogram (rate, errors and duration).",
		ConstLabels: constLabels,
		Buckets:     prometheus.ExponentialBuckets(100, 2, 5),
	}

	red := IncomeRepoWithRED{
		base:         base,
		histogramVec: prometheus.NewHistogramVec(metricConfig, []string{"status", "method"}),
	}

	err = instrumentation.Registry.Register(red.histogramVec)
	if err != nil {
		return nil, err
	}

	return red, nil
}
